{
  "id": "4e4024d2-38cf-4711-9a97-51f8d7cd8d0c",
  "status": "processing",
  "chunks": [
    "SUMMARY",
    ":\nThe code is a React hook, `useReviewStream`, that manages",
    " the state and logic for an asynchronous code review process. It handles starting a review",
    ", polling for status updates, fetching the final result, repairing parsing errors, and updating suggestions.\n\nThe code demonstrates a good understanding of React hooks and asynchronous JavaScript",
    ". However, there are several areas where the code can be improved for readability, maintainability, and robustness, particularly around state management, error handling, and code",
    " duplication. The use of refs for managing polling state is generally good, but there's room for simplification. The content completion check could be improved to be more robust.\n\nSUGGESTIONS:\nLINE: 155\nORIGINAL:",
    " `const hasSummary = /SUMMARY:|Summary:|summary:/i.test(text);`\nSUGGESTED: `const hasSummary = /SUMMARY:/i.test(text);`\nEXPLANATION: Simplify the regex",
    ". The `/i` flag makes the regex case-insensitive, so we only need to specify one capitalization of \"SUMMARY\". This reduces visual clutter. Apply similar changes for `hasSuggestions` and `hasCleanCode`\n\nLINE: 216\nORIGINAL: `const errorData = await response.json().catch(()",
    " => ({}));`\nSUGGESTED: `const errorData = await response.json().catch(() => ({ error: 'Failed to parse error response' }));`\nEXPLANATION: Improves error handling. If `response.json()` fails, it's likely due to a malformed JSON response from",
    " the server. Providing a default error message helps with debugging. This pattern is repeated several times in the code.\n\nLINE: 237\nORIGINAL:\n```javascript\n      let parsed: CodeReviewResponse = {\n        summary: '',\n        suggestions: [],\n        cleanCode: ''\n      ",
    "};\n```\nSUGGESTED: `const defaultParsedResponse: CodeReviewResponse = { summary: '', suggestions: [], cleanCode: '' };`\n`let parsed: CodeReviewResponse = defaultParsedResponse;`\nEXPLANATION: Define default response as a constant. This makes it clear that the default",
    " parsed response is a fixed value and prevents accidental modification. It also improves readability by extracting the default value definition.\n\nLINE: 290\nORIGINAL:\n```javascript\n        return {\n          ...prev,\n          status,\n          rawText: resultData.rawText || prev.rawText,",
    "\n          parsed,\n          parseError: resultData.parseError || null,\n          error: resultData.error || null,\n          progress: 100\n        };\n```\nSUGGESTED:\n```javascript\n        return {\n          ...prev,\n          status,\n",
    "          rawText: resultData.rawText ?? prev.rawText,\n          parsed,\n          parseError: resultData.parseError ?? null,\n          error: resultData.error ?? null,\n          progress: 100\n        };\n```\nEXPLANATION: Use the null",
    "ish coalescing operator (`??`) instead of the logical OR operator (`||`).  The `||` operator will use the right-hand side operand if the left-hand side is any falsy value (e.g., `''`, `0`, `false`, `null`, `undefined`). The `??",
    "` operator only considers `null` or `undefined` as the left-hand side value to use the right-hand side operand. This prevents unexpected behavior if `resultData.rawText`, `resultData.parseError`, or `resultData.error` are empty strings, which are valid values.\n\nLINE:",
    " 367\nORIGINAL: `const progress = statusData.chunks?.length > 0 ?`\nSUGGESTED: `const progress = statusData.chunks?.length ?`\nEXPLANATION: Simplify the conditional. `statusData.chunks?.length > 0` is redundant;",
    " `statusData.chunks?.length` is already truthy if the length is greater than 0.\n\nLINE: 416\nORIGINAL:\n```javascript\n        switch(serverStatus) {\n          case 'completed':\n            uiStatus = 'completed';\n            break;\n          case 'processing",
    "':\n            uiStatus = 'processing';\n            break;\n          case 'queued':\n            uiStatus = 'loading';\n            break;\n          case 'error':\n            uiStatus = 'error';\n            break;\n          case 'repairing':\n            uiStatus = 'repairing",
    "';\n            break;\n          default:\n            // Keep existing status if unknown\n            console.warn(`Unknown server status: ${statusData.status}`);\n            break;\n        }\n```\nSUGGESTED:\n```javascript\n        uiStatus = ((): ReviewStreamState => {\n          switch",
    "(serverStatus) {\n            case 'completed': return 'completed';\n            case 'processing': return 'processing';\n            case 'queued': return 'loading';\n            case 'error': return 'error';\n            case 'repairing': return 'repairing';\n            default:\n              console",
    ".warn(`Unknown server status: ${statusData.status}`);\n              return prev.status;\n          }\n        })();\n```\nEXPLANATION: Use an Immediately Invoked Function Expression (IIFE) to make the status mapping more concise and readable. This clarifies that the purpose of the switch statement is to determine",
    " the `uiStatus` and avoids potential fall-through issues if `break` statements are missed.  It also makes the logic more self-contained.\n\nLINE: 496\nORIGINAL:\n```javascript\n    setReviewState({\n      reviewId: null,\n      status: 'loading",
    "',\n      rawText: '',\n      parsed: {\n        summary: '',\n        suggestions: [],\n        cleanCode: ''\n      },\n      parseError: null,\n      error: null,\n      language,\n      filename,\n      progress: 0\n    });\n```\n",
    "SUGGESTED:\n```javascript\n    setReviewState(prevState => ({\n      ...prevState,\n      reviewId: null,\n      status: 'loading',\n      rawText: '',\n      parsed: defaultParsedResponse,\n      parseError: null,\n      error: null,\n      language,",
    "\n      filename,\n      progress: 0\n    }));\n```\nEXPLANATION: Instead of directly setting the state, use the functional update form of `setReviewState` and include the previous state. This ensures that you are not accidentally dropping any state properties that might have been added in the future. Use",
    " `defaultParsedResponse` defined earlier.\n\nLINE: 587\nORIGINAL:\n```javascript\n        setReviewState(prev => ({\n          ...prev,\n          status: 'completed',\n          parsed: data.result,\n          parseError: null\n        }));\n```\nSU",
    "GGESTED:\n```javascript\n        setReviewState(prev => ({\n          ...prev,\n          status: 'completed',\n          parsed: data.result,\n          parseError: null,\n          error: null\n        }));\n```\nEXPLANATION: Reset the `error` state to `",
    "null` when repair is successful. This ensures that any previous error message is cleared, providing a cleaner UI experience.\n\nLINE: 643\nORIGINAL: `addReview(storedReview);`\nSUGGESTED: `void addReview(storedReview);`\nEXPLANATION: Mark the call",
    " to `addReview` as `void`. `addReview` is presumably an asynchronous function (given its use of local storage). We are not awaiting its completion, so marking the call as void signals that we are intentionally ignoring the result and any potential errors. This avoids linters warning about unhandled promises.\n\nLINE:",
    " 142\nORIGINAL: `  const isReviewContentComplete = useCallback((text: string, chunkCount: number): boolean => {`\nSUGGESTED:\n```javascript\nconst isReviewContentComplete = useCallback(\n  (text: string, chunkCount: number): boolean => {\n    ",
    "const hasAllSections =\n      /SUMMARY:/i.test(text) &&\n      /SUGGESTIONS:/i.test(text) &&\n      /CLEAN[_\\s]CODE:/i.test(text);\n\n    if (!hasAllSections) {\n      console.log(",
    "\n        `Missing required sections: Summary: ${/SUMMARY:/i.test(text)}, Suggestions: ${/SUGGESTIONS:/i.test(\n          text\n        )}, CleanCode: ${/CLEAN[_\\s]CODE:/i.test(text)}`\n      );\n      return false",
    ";\n    }\n\n    const cleanCodeMatch = text.match(\n      /(?:CLEAN[_\\s]CODE:|Clean[_\\s]Code:|clean[_\\s]code:)([\\s\\S]*?)$/i\n    );\n    if (\n      !cleanCodeMatch ||",
    "\n      !cleanCodeMatch[1] ||\n      cleanCodeMatch[1].length < 100\n    ) {\n      console.log(\"Clean code section is missing or too short\");\n      return false;\n    }\n\n    const parseResult = parseReviewText(text);\n    return",
    " parseResult.success && !!parseResult.result;\n  },\n  []\n);\n```\nEXPLANATION: Refactor `isReviewContentComplete` to improve readability and performance:\n1.  Combine all section checks into a single `hasAllSections` variable for conciseness.\n2.  Move",
    " the section check to the top to fail early if any section is missing, improving performance.\n3.  Use `!!parseResult.result` to explicitly convert the result to a boolean.\n4.  Remove the time and chunk count checks from the `isReviewContentComplete` function. These checks are better",
    " handled in the calling function, `pollReviewStatus`, because they represent external conditions that influence when the content should be checked, not whether the content itself is complete. This separation of concerns makes the function more focused and testable.\n\nLINE: 351\nORIGINAL:\n```javascript\n        // Check content",
    "-based completion\n        if (statusData.chunks?.length > 0) {\n          const rawText = statusData.chunks.join('');\n          const chunkCount = statusData.chunks.length;\n          \n          // Check if content suggests the review is complete\n          if (isReviewContent",
    "Complete(rawText, chunkCount)) {\n            console.log('Review appears complete based on content analysis, fetching final result');\n            await fetchFinalResult(reviewId);\n            stopPolling();\n            return;\n          }\n        }\n```\nSUGGESTED:\n```javascript\n        //",
    " Check content-based completion\n        if (statusData.chunks?.length > 0) {\n          const rawText = statusData.chunks.join('');\n          const chunkCount = statusData.chunks.length;\n\n          // Check if enough time has passed since the review started\n          if (review",
    "StartTimeRef.current) {\n            const timeSinceStart = Date.now() - reviewStartTimeRef.current;\n            if (timeSinceStart < MIN_COMPLETION_TIME_MS) {\n              console.log(\n                `Only ${Math.round(\n                  timeSinceStart / 10",
    "00\n                )}s since review started, not checking content completion yet`\n              );\n              break;\n            }\n          }\n\n          if (chunkCount < MIN_CHUNKS_FOR_COMPLETION) {\n            console.log(\"Not enough chunks received, skipping content completion check",
    "\");\n            break;\n          }\n\n          // Check if content suggests the review is complete\n          if (isReviewContentComplete(rawText, chunkCount)) {\n            console.log(\n              \"Review appears complete based on content analysis, fetching final result\"\n            );\n            await fetchFinal",
    "Result(reviewId);\n            stopPolling();\n            return;\n          }\n        }\n```\nEXPLANATION: Move the time and chunk count checks to the `pollReviewStatus` function, before calling `isReviewContentComplete`, as suggested in the `isReviewContentComplete` refactoring explanation",
    ".\n\nCLEAN_CODE:\n```javascript\nimport { useState, useCallback, useEffect, useRef } from 'react';\nimport { parseReviewText } from '@/lib/text-parser';\nimport { CodeReviewResponse } from '@/lib/prompts';\nimport { createStorableReview, addReview",
    " } from '@/lib/storage-utils';\nimport { Language, getLanguageById } from '@/lib/language-utils';\n\n/**\n * States for the review process\n */\nexport type ReviewStreamState = \n  | 'idle'\n  | 'loading'\n  | 'processing'\n",
    "  | 'streaming'\n  | 'completed'\n  | 'repairing'\n  | 'error';\n\n/**\n * Review state\n */\nexport interface ReviewState {\n  reviewId: string | null;\n  status: ReviewStreamState;\n  rawText: string;\n  ",
    "parsed: CodeReviewResponse;\n  parseError: string | null;\n  error: string | null;\n  language: Language;\n  filename?: string;\n  progress?: number; // Progress indicator (0-100)\n}\n\n// Polling interval constants\nconst INITIAL_POLL_INTERVAL",
    " = 1000; // 1 second\nconst MAX_POLL_INTERVAL = 5000; // 5 seconds\nconst POLL_BACKOFF_FACTOR = 1.5; // Increase interval by 50% each time\nconst MIN_COMPLETION_TIME_MS",
    " = 10000; // 10 seconds - minimum time before considering content-based completion\nconst MIN_CHUNKS_FOR_COMPLETION = 10; // Need at least this many chunks before considering content-based completion\n\nconst defaultParsedResponse: CodeReviewResponse = {",
    " summary: '', suggestions: [], cleanCode: '' };\n\n/**\n * Custom hook for managing asynchronous code reviews\n * @returns An object with the review state and control functions\n */\nexport function useReviewStream() {\n  const [reviewState, setReviewState] = useState<ReviewState>({\n",
    "    reviewId: null,\n    status: 'idle',\n    rawText: '',\n    parsed: defaultParsedResponse,\n    parseError: null,\n    error: null,\n    language: getLanguageById('javascript')\n  });\n  \n  // Reference to the current polling timer\n  ",
    "const pollingTimerRef = useRef<NodeJS.Timeout | null>(null);\n  \n  // Reference to current polling interval\n  const pollIntervalRef = useRef(INITIAL_POLL_INTERVAL);\n  \n  // Reference to whether polling is active\n  const isPollingRef = useRef(false);\n  \n",
    "  // Reference to review start time (for timing-based decisions)\n  const reviewStartTimeRef = useRef<number | null>(null);\n  \n  /**\n   * Stops any active polling\n   */\n  const stopPolling = useCallback(() => {\n    if (pollingTimerRef.current) {\n      ",
    "clearTimeout(pollingTimerRef.current);\n      pollingTimerRef.current = null;\n    }\n    isPollingRef.current = false;\n    pollIntervalRef.current = INITIAL_POLL_INTERVAL;\n    console.log('Polling stopped');\n  }, []);\n  \n    ",
    "/**\n   * Determines if a review is complete based on content analysis\n   * @param text - Raw text content to analyze\n   * @param chunkCount - Number of chunks received so far\n   * @returns Whether the review appears complete\n   */\n  const isReviewContentComplete = useCallback(\n    (text",
    ": string, chunkCount: number): boolean => {\n      const hasAllSections =\n        /SUMMARY:/i.test(text) &&\n        /SUGGESTIONS:/i.test(text) &&\n        /CLEAN[_\\s]CODE:/i.test(text);\n\n      if (!has",
    "AllSections) {\n        console.log(\n          `Missing required sections: Summary: ${/SUMMARY:/i.test(text)}, Suggestions: ${/SUGGESTIONS:/i.test(\n            text\n          )}, CleanCode: ${/CLEAN[_\\s]CODE:/i.test(text",
    ")}`\n        );\n        return false;\n      }\n\n      const cleanCodeMatch = text.match(\n        /(?:CLEAN[_\\s]CODE:|Clean[_\\s]Code:|clean[_\\s]code:)([\\s\\S]*?)$/i\n      );\n",
    "      if (\n        !cleanCodeMatch ||\n        !cleanCodeMatch[1] ||\n        cleanCodeMatch[1].length < 100\n      ) {\n        console.log(\"Clean code section is missing or too short\");\n        return false;\n      }\n\n      const parse",
    "Result = parseReviewText(text);\n      return parseResult.success && !!parseResult.result;\n    },\n    []\n  );\n  \n  /**\n   * Fetches the final result of a review\n   * @param reviewId - The ID of the review\n   */\n",
    "  const fetchFinalResult = useCallback(async (reviewId: string) => {\n    try {\n      console.log(`Fetching final result for review ${reviewId}`);\n      const response = await fetch(`/api/review/result?id=${reviewId}`);\n      \n      if (!response.ok",
    ") {\n        const errorData = await response.json().catch(() => ({ error: 'Failed to parse error response' }));\n        throw new Error(`Failed to get review result: ${response.status} - ${errorData?.error || 'Unknown error'}`);\n      }\n      \n      const",
    " resultData = await response.json();\n      console.log('Received final result:', resultData);\n      \n      // Determine status based on the response\n      let status: ReviewStreamState = 'completed';\n      \n      if (resultData.error) {\n        status = 'error';\n        ",
    "console.error('Error in result:', resultData.error);\n      } else if (resultData.parseError) {\n        status = 'repairing';\n        console.warn('Parse error in result:', resultData.parseError);\n      }\n      \n      // Get the parsed response or",
    " create a default one\n      let parsed: CodeReviewResponse = defaultParsedResponse;\n      \n      if (resultData.parsedResponse) {\n        parsed = resultData.parsedResponse;\n        console.log('Successfully parsed response:', parsed);\n      } else {\n        // Try to parse ourselves",
    " if server didn't provide a parsed response\n        console.log('Attempting to parse raw text on client side');\n        const parseResult = parseReviewText(resultData.rawText || '');\n        if (parseResult.success && parseResult.result) {\n          parsed = parseResult.",
    "result;\n          console.log('Client-side parsing succeeded');\n        } else if (parseResult.error) {\n          console.warn('Client-side parsing failed:', parseResult.error);\n        }\n      }\n      \n      setReviewState(prev => {\n        // If completed",
    " successfully, save to local storage\n        if (status === 'completed' && reviewId && parsed.summary && parsed.cleanCode) {\n          console.log('Saving completed review to local storage');\n          const storedReview = createStorableReview(\n            reviewId,\n            parsed,\n            ",
    "prev.language.id,\n            prev.filename\n          );\n          void addReview(storedReview);\n        }\n        \n        return {\n          ...prev,\n          status,\n          rawText: resultData.rawText ?? prev.rawText,\n          parsed,\n          parseError",
    ": resultData.parseError ?? null,\n          error: resultData.error ?? null,\n          progress: 100\n        };\n      });\n      \n      // Ensure polling is stopped after fetching final result\n      stopPolling();\n    } catch (error) {\n      console.error('",
    "Error fetching final result:', error);\n      \n      setReviewState(prev => ({ \n        ...prev, \n        status: 'error', \n        error: error instanceof Error ? error.message : 'Unknown error fetching result',\n        progress: 100\n      }));\n      ",
    "\n      // Ensure polling is stopped on error\n      stopPolling();\n    }\n  }, [stopPolling]); \n  \n  /**\n   * Polls the status of a review\n   * @param reviewId - The ID of the review to poll\n   */\n  const pollReviewStatus = useCallback",
    "(async (reviewId: string) => {\n    if (!reviewId || !isPollingRef.current) {\n      console.log('Polling skipped - inactive or missing reviewId');\n      return;\n    }\n    \n    try {\n      // Fetch the current status\n      console.log(`Polling",
    " status for review ${reviewId}`);\n      const response = await fetch(`/api/review/status?id=${reviewId}`);\n      \n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({ error: 'Failed to parse error response' }));\n        throw new",
    " Error(`Failed to get review status: ${response.status} - ${errorData?.error || 'Unknown error'}`);\n      }\n      \n      const statusData = await response.json();\n      console.log('Received status data:', {\n        status: statusData.status, \n        chunks:",
    " statusData.chunks?.length || 0,\n        isComplete: statusData.isComplete\n      });\n      \n      // Check for explicit completion markers from server\n      const serverStatus = statusData.status?.toLowerCase();\n      const serverSaysComplete = \n        statusData.isComplete ===",
    " true || \n        serverStatus === 'completed' || \n        serverStatus === 'error';\n        \n      console.log(`Server status: '${serverStatus}', server says complete: ${serverSaysComplete}`);\n      \n      // If the server explicitly indicates completion\n      if (serverSaysComplete) {\n",
    "        console.log('Server indicates review is complete, fetching final result and stopping polling');\n        await fetchFinalResult(reviewId);\n        stopPolling();\n        return;\n      }\n      \n      // Check content-based completion\n      if (statusData.chunks?.length > 0) {\n        ",
    "const rawText = statusData.chunks.join('');\n        const chunkCount = statusData.chunks.length;\n\n        // Check if enough time has passed since the review started\n        if (reviewStartTimeRef.current) {\n          const timeSinceStart = Date.now() - reviewStartTimeRef.current;\n",
    "          if (timeSinceStart < MIN_COMPLETION_TIME_MS) {\n            console.log(\n              `Only ${Math.round(\n                timeSinceStart / 1000\n              )}s since review started, not checking content completion yet`\n            );\n            break",
    ";\n          }\n        }\n\n        if (chunkCount < MIN_CHUNKS_FOR_COMPLETION) {\n          console.log(\"Not enough chunks received, skipping content completion check\");\n          break;\n        }\n\n        // Check if content suggests the review is complete\n        if",
    " (isReviewContentComplete(rawText, chunkCount)) {\n          console.log(\n            \"Review appears complete based on content analysis, fetching final result\"\n          );\n          await fetchFinalResult(reviewId);\n          stopPolling();\n          return;\n        }\n      }\n      \n      ",
    "// Continue with status update if not complete\n      setReviewState(prev => {\n        // Calculate progress based on chunks (approximate)\n        const progress = statusData.chunks?.length ? \n          Math.min(Math.floor((statusData.chunks.length / 50) * 1",
    "00), 95) : \n          prev.progress || 10;\n        \n        // Update the raw text with all chunks\n        const newRawText = statusData.chunks?.join('') || '';\n        \n        // Try to parse the results if we have content\n        let",
    " parsed = prev.parsed;\n        let parseError = null;\n        \n        if (newRawText && newRawText !== prev.rawText) {\n          const parsedResult = parseReviewText(newRawText);\n          if (parsedResult.success && parsedResult.result) {\n            parsed =",
    " parsedResult.result;\n            console.log('Successfully parsed partial response');\n          } else if (parsedResult.error) {\n            parseError = parsedResult.error;\n            console.warn('Parse error for partial response:', parsedResult.error);\n          }\n        }\n        \n        //",
    " Map API status to UI status - explicitly handle all known server statuses\n        let uiStatus: ReviewStreamState = prev.status;\n        \n        uiStatus = ((): ReviewStreamState => {\n          switch(serverStatus) {\n            case 'completed': return 'completed';\n            case 'processing",
    "': return 'processing';\n            case 'queued': return 'loading';\n            case 'error': return 'error';\n            case 'repairing': return 'repairing';\n            default:\n              console.warn(`Unknown server status: ${statusData.status}`);\n              return prev.status;\n",
    "          }\n        })();\n        \n        console.log(`Mapped to UI status: '${uiStatus}'`);\n\n        return {\n          ...prev,\n          status: uiStatus,\n          rawText: newRawText,\n          parsed,\n          parseError,\n          progress,\n          error:",
    " statusData.error || null\n        };\n      });\n      \n      // Continue polling with backoff\n      pollIntervalRef.current = Math.min(\n        pollIntervalRef.current * POLL_BACKOFF_FACTOR, \n        MAX_POLL_INTERVAL\n      );\n      \n      console.",
    "log(`Next poll in ${pollIntervalRef.current}ms`);\n      \n      pollingTimerRef.current = setTimeout(\n        () => pollReviewStatus(reviewId), \n        pollIntervalRef.current\n      );\n    } catch (error) {\n      console.error('Error polling review status",
    ":', error);\n      \n      // Update state with error\n      setReviewState(prev => ({ \n        ...prev, \n        status: 'error', \n        error: error instanceof Error ? error.message : 'Unknown error polling review status'\n      }));\n      \n      stopPolling();\n    ",
    "}\n  }, [fetchFinalResult, stopPolling, isReviewContentComplete]); \n  \n  /**\n   * Starts a new code review\n   * @param code - The code to review\n   * @param language - The programming language\n   * @param filename - Optional filename\n   */\n",
    "  const startReview = useCallback(async (\n    code: string,\n    language: Language,\n    filename?: string\n  ) => {\n    // Stop any existing polling\n    stopPolling();\n    \n    // Reset state and tracking variables\n    reviewStartTimeRef.current = Date.now(); // Track",
    " when we started\n    \n    setReviewState(prevState => ({\n      ...prevState,\n      reviewId: null,\n      status: 'loading',\n      rawText: '',\n      parsed: defaultParsedResponse,\n      parseError: null,\n      error: null,\n      language,",
    "\n      filename,\n      progress: 0\n    }));\n    \n    try {\n      console.log(`[Client] Starting review for ${filename || 'unnamed code'}, language: ${language.id}`);\n      \n      // Create the request\n      const response = await fetch('/api/review/",
    "start', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ \n          code,\n          language: language.id,\n          filename\n        })\n      });\n      \n      if (!response.ok",
    ") {\n        const errorData = await response.json().catch(() => ({ error: 'Failed to parse error response' }));\n        throw new Error(`Failed to start review: ${response.status} - ${errorData?.error || 'Unknown error'}`);\n      }\n      \n      const data",
    " = await response.json();\n      \n      console.log(`[Client] Review started with ID: ${data.reviewId}`);\n      \n      // Set processing status\n      setReviewState(prev => ({\n        ...prev,\n        reviewId: data.reviewId,\n        status: '",
    "processing',\n        progress: 5\n      }));\n      \n      // Start polling for updates\n      isPollingRef.current = true;\n      pollIntervalRef.current = INITIAL_POLL_INTERVAL;\n      \n      console.log(`Starting first poll in ${pollIntervalRef.current}ms`);",
    "\n      pollingTimerRef.current = setTimeout(\n        () => pollReviewStatus(data.reviewId), \n        pollIntervalRef.current\n      );\n      \n    } catch (error) {\n      console.error('[Client] Error starting review:', error);\n      \n      setReviewState(",
    "prev => ({ \n        ...prev, \n        status: 'error', \n        error: error instanceof Error ? error.message : 'Unknown error starting review'\n      }));\n    }\n  }, [stopPolling, pollReviewStatus]);\n\n  /**\n   * Force refreshes the current",
    " review\n   */\n  const forceRefreshReview = useCallback(() => {\n    if (reviewState.reviewId) {\n      console.log(`Force refreshing review ${reviewState.reviewId}`);\n      // Stop any ongoing polling\n      stopPolling();\n      // Fetch the final result\n      fetch",
    "FinalResult(reviewState.reviewId);\n    } else {\n      console.warn('Cannot force refresh - no review ID');\n    }\n  }, [reviewState.reviewId, fetchFinalResult, stopPolling]);\n\n  /**\n   * Attempts to repair a malformed response\n   */\n  const",
    " repairParsing = useCallback(async () => {\n    if (!reviewState.rawText || !reviewState.parseError || !reviewState.reviewId) {\n      console.warn('Cannot repair without raw text, parse error, or review ID');\n      return;\n    }\n    \n    try {\n",
    "      console.log('[Client] Attempting to repair malformed response');\n      \n      // Stop any ongoing polling\n      stopPolling();\n      \n      setReviewState(prev => ({ \n        ...prev, \n        status: 'repairing' \n      }));\n      \n      const",
    " response = await fetch('/api/review/repair', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ \n          rawText: reviewState.rawText,\n          language: reviewState.language.",
    "id,\n          reviewId: reviewState.reviewId\n        })\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({ error: 'Failed to parse error response' }));\n        throw new Error(`Repair failed: ${response",
    ".status} - ${errorData?.error || 'Unknown error'}`);\n      }\n      \n      const data = await response.json();\n      console.log('Repair response:', data);\n      \n      if (data.success) {\n        console.log('[Client] Successfully repaired parsing issues');\n",
    "        \n        setReviewState(prev => ({\n          ...prev,\n          status: 'completed',\n          parsed: data.result,\n          parseError: null,\n          error: null\n        }));\n        \n        // Save to localStorage\n        const storedReview = createStorableReview(\n",
    "          reviewState.reviewId as string,\n          data.result,\n          reviewState.language.id,\n          reviewState.filename\n        );\n        void addReview(storedReview);\n      } else {\n        throw new Error(data.error || 'Failed to repair parsing');\n      }",
    "\n    } catch (error) {\n      console.error('[Client] Error repairing response:', error);\n      \n      setReviewState(prev => ({ \n        ...prev, \n        status: 'error',\n        error: error instanceof Error ? error.message : 'Unknown error repairing response'\n      ",
    "}));\n    }\n  }, [reviewState.rawText, reviewState.parseError, reviewState.reviewId, reviewState.language, reviewState.filename, stopPolling]);\n  \n  /**\n   * Updates a suggestion's acceptance status\n   * @param suggestionId - The ID of",
    " the suggestion\n   * @param accepted - Whether the suggestion is accepted\n   */\n  const updateSuggestion = useCallback((suggestionId: string, accepted: boolean | null) => {\n    setReviewState(prev => {\n      const updatedSuggestions = prev.parsed.suggestions.map(suggestion => \n        ",
    "suggestion.id === suggestionId\n          ? { ...suggestion, accepted }\n          : suggestion\n      );\n      \n      const updatedParsed = {\n        ...prev.parsed,\n        suggestions: updatedSuggestions\n      };\n      \n      // If we have a completed review and a valid ID, update the",
    " stored review\n      if (prev.status === 'completed' && prev.reviewId) {\n        const storedReview = createStorableReview(\n          prev.reviewId,\n          updatedParsed,\n          prev.language.id,\n          prev.filename\n        );\n        void addReview(stored",
    "Review);\n      }\n      \n      return {\n        ...prev,\n        parsed: updatedParsed\n      };\n    });\n  }, []);\n  \n  // Clean up polling on unmount\n  useEffect(() => {\n    return () => {\n      if (pollingTimerRef.current) {",
    "\n        clearTimeout(pollingTimerRef.current);\n      }\n    };\n  }, []);\n  \n  return {\n    reviewState,\n    startReview,\n    forceRefreshReview,\n    repairParsing,\n    updateSuggestion\n  };\n}\n```"
  ],
  "error": null,
  "timestamp": 1740980394587,
  "lastUpdated": 1740980435540,
  "parsedResponse": {
    "summary": "The code is a React hook, `useReviewStream`, that manages the state and logic for an asynchronous code review process. It handles starting a review, polling for status updates, fetching the final result, repairing parsing errors, and updating suggestions.\n\nThe code demonstrates a good understanding of React hooks and asynchronous JavaScript. However, there are several areas where the code can be improved for readability, maintainability, and robustness, particularly around state management, error handling, and code duplication. The use of refs for managing polling state is generally good, but there's room for simplification. The content completion check could be improved to be more robust.",
    "suggestions": [
      {
        "id": "520586ca-8cde-4606-8e6a-55ffc45e8410",
        "lineNumber": 155,
        "originalCode": "`const hasSummary = /SUMMARY:|Summary:|summary:/i.test(text);`",
        "suggestedCode": "`const hasSummary = /SUMMARY:/i.test(text);`",
        "explanation": "Simplify the regex. The `/i` flag makes the regex case-insensitive, so we only need to specify one capitalization of \"SUMMARY\". This reduces visual clutter. Apply similar changes for `hasSuggestions` and `hasCleanCode`",
        "accepted": null
      },
      {
        "id": "187a63fd-73ca-4ee1-8dda-64602f3f0fa7",
        "lineNumber": 216,
        "originalCode": "`const errorData = await response.json().catch(() => ({}));`",
        "suggestedCode": "`const errorData = await response.json().catch(() => ({ error: 'Failed to parse error response' }));`",
        "explanation": "Improves error handling. If `response.json()` fails, it's likely due to a malformed JSON response from the server. Providing a default error message helps with debugging. This pattern is repeated several times in the code.",
        "accepted": null
      },
      {
        "id": "2d04ee81-05c1-4336-8a99-306937a1f927",
        "lineNumber": 237,
        "originalCode": "      let parsed: CodeReviewResponse = {\n        summary: '',\n        suggestions: [],\n        cleanCode: ''\n      };",
        "suggestedCode": "`const defaultParsedResponse: CodeReviewResponse = { summary: '', suggestions: [], cleanCode: '' };`\n`let parsed: CodeReviewResponse = defaultParsedResponse;`",
        "explanation": "Define default response as a constant. This makes it clear that the default parsed response is a fixed value and prevents accidental modification. It also improves readability by extracting the default value definition.",
        "accepted": null
      },
      {
        "id": "0bc0cddb-96d6-48e7-af9f-bfb0502dff2d",
        "lineNumber": 290,
        "originalCode": "        return {\n          ...prev,\n          status,\n          rawText: resultData.rawText || prev.rawText,\n          parsed,\n          parseError: resultData.parseError || null,\n          error: resultData.error || null,\n          progress: 100\n        };",
        "suggestedCode": "        return {\n          ...prev,\n          status,\n          rawText: resultData.rawText ?? prev.rawText,\n          parsed,\n          parseError: resultData.parseError ?? null,\n          error: resultData.error ?? null,\n          progress: 100\n        };",
        "explanation": "Use the nullish coalescing operator (`??`) instead of the logical OR operator (`||`).  The `||` operator will use the right-hand side operand if the left-hand side is any falsy value (e.g., `''`, `0`, `false`, `null`, `undefined`). The `??` operator only considers `null` or `undefined` as the left-hand side value to use the right-hand side operand. This prevents unexpected behavior if `resultData.rawText`, `resultData.parseError`, or `resultData.error` are empty strings, which are valid values.",
        "accepted": null
      },
      {
        "id": "9bb2fbd2-7016-4ce3-9015-3515f3a17803",
        "lineNumber": 367,
        "originalCode": "`const progress = statusData.chunks?.length > 0 ?`",
        "suggestedCode": "`const progress = statusData.chunks?.length ?`",
        "explanation": "Simplify the conditional. `statusData.chunks?.length > 0` is redundant; `statusData.chunks?.length` is already truthy if the length is greater than 0.",
        "accepted": null
      },
      {
        "id": "dbcea739-0164-4250-8694-26fe2dcbe30a",
        "lineNumber": 416,
        "originalCode": "        switch(serverStatus) {\n          case 'completed':\n            uiStatus = 'completed';\n            break;\n          case 'processing':\n            uiStatus = 'processing';\n            break;\n          case 'queued':\n            uiStatus = 'loading';\n            break;\n          case 'error':\n            uiStatus = 'error';\n            break;\n          case 'repairing':\n            uiStatus = 'repairing';\n            break;\n          default:\n            // Keep existing status if unknown\n            console.warn(`Unknown server status: ${statusData.status}`);\n            break;\n        }",
        "suggestedCode": "        uiStatus = ((): ReviewStreamState => {\n          switch(serverStatus) {\n            case 'completed': return 'completed';\n            case 'processing': return 'processing';\n            case 'queued': return 'loading';\n            case 'error': return 'error';\n            case 'repairing': return 'repairing';\n            default:\n              console.warn(`Unknown server status: ${statusData.status}`);\n              return prev.status;\n          }\n        })();",
        "explanation": "Use an Immediately Invoked Function Expression (IIFE) to make the status mapping more concise and readable. This clarifies that the purpose of the switch statement is to determine the `uiStatus` and avoids potential fall-through issues if `break` statements are missed.  It also makes the logic more self-contained.",
        "accepted": null
      },
      {
        "id": "c129b751-acda-4a5f-b6e2-bf03404364c7",
        "lineNumber": 496,
        "originalCode": "    setReviewState({\n      reviewId: null,\n      status: 'loading',\n      rawText: '',\n      parsed: {\n        summary: '',\n        suggestions: [],\n        cleanCode: ''\n      },\n      parseError: null,\n      error: null,\n      language,\n      filename,\n      progress: 0\n    });",
        "suggestedCode": "    setReviewState(prevState => ({\n      ...prevState,\n      reviewId: null,\n      status: 'loading',\n      rawText: '',\n      parsed: defaultParsedResponse,\n      parseError: null,\n      error: null,\n      language,\n      filename,\n      progress: 0\n    }));",
        "explanation": "Instead of directly setting the state, use the functional update form of `setReviewState` and include the previous state. This ensures that you are not accidentally dropping any state properties that might have been added in the future. Use `defaultParsedResponse` defined earlier.",
        "accepted": null
      },
      {
        "id": "569604df-7b3f-403a-a6a2-99fb6e033d02",
        "lineNumber": 587,
        "originalCode": "        setReviewState(prev => ({\n          ...prev,\n          status: 'completed',\n          parsed: data.result,\n          parseError: null\n        }));",
        "suggestedCode": "        setReviewState(prev => ({\n          ...prev,\n          status: 'completed',\n          parsed: data.result,\n          parseError: null,\n          error: null\n        }));",
        "explanation": "Reset the `error` state to `null` when repair is successful. This ensures that any previous error message is cleared, providing a cleaner UI experience.",
        "accepted": null
      },
      {
        "id": "5f3cdcc8-2039-4006-95c4-0ca2424f726c",
        "lineNumber": 643,
        "originalCode": "`addReview(storedReview);`",
        "suggestedCode": "`void addReview(storedReview);`",
        "explanation": "Mark the call to `addReview` as `void`. `addReview` is presumably an asynchronous function (given its use of local storage). We are not awaiting its completion, so marking the call as void signals that we are intentionally ignoring the result and any potential errors. This avoids linters warning about unhandled promises.",
        "accepted": null
      },
      {
        "id": "ec784d8a-4441-4f31-b65c-aeac79074b4e",
        "lineNumber": 142,
        "originalCode": "`  const isReviewContentComplete = useCallback((text: string, chunkCount: number): boolean => {`",
        "suggestedCode": "const isReviewContentComplete = useCallback(\n  (text: string, chunkCount: number): boolean => {\n    const hasAllSections =\n      /SUMMARY:/i.test(text) &&\n      /SUGGESTIONS:/i.test(text) &&\n      /CLEAN[_\\s]CODE:/i.test(text);\n\n    if (!hasAllSections) {\n      console.log(\n        `Missing required sections: Summary: ${/SUMMARY:/i.test(text)}, Suggestions: ${/SUGGESTIONS:/i.test(\n          text\n        )}, CleanCode: ${/CLEAN[_\\s]CODE:/i.test(text)}`\n      );\n      return false;\n    }\n\n    const cleanCodeMatch = text.match(\n      /(?:CLEAN[_\\s]CODE:|Clean[_\\s]Code:|clean[_\\s]code:)([\\s\\S]*?)$/i\n    );\n    if (\n      !cleanCodeMatch ||\n      !cleanCodeMatch[1] ||\n      cleanCodeMatch[1].length < 100\n    ) {\n      console.log(\"Clean code section is missing or too short\");\n      return false;\n    }\n\n    const parseResult = parseReviewText(text);\n    return parseResult.success && !!parseResult.result;\n  },\n  []\n);",
        "explanation": "Refactor `isReviewContentComplete` to improve readability and performance:\n1.  Combine all section checks into a single `hasAllSections` variable for conciseness.\n2.  Move the section check to the top to fail early if any section is missing, improving performance.\n3.  Use `!!parseResult.result` to explicitly convert the result to a boolean.\n4.  Remove the time and chunk count checks from the `isReviewContentComplete` function. These checks are better handled in the calling function, `pollReviewStatus`, because they represent external conditions that influence when the content should be checked, not whether the content itself is complete. This separation of concerns makes the function more focused and testable.",
        "accepted": null
      },
      {
        "id": "18d9ea73-6067-4eef-976d-5b7b931fb63b",
        "lineNumber": 351,
        "originalCode": "        // Check content-based completion\n        if (statusData.chunks?.length > 0) {\n          const rawText = statusData.chunks.join('');\n          const chunkCount = statusData.chunks.length;\n          \n          // Check if content suggests the review is complete\n          if (isReviewContentComplete(rawText, chunkCount)) {\n            console.log('Review appears complete based on content analysis, fetching final result');\n            await fetchFinalResult(reviewId);\n            stopPolling();\n            return;\n          }\n        }",
        "suggestedCode": "        // Check content-based completion\n        if (statusData.chunks?.length > 0) {\n          const rawText = statusData.chunks.join('');\n          const chunkCount = statusData.chunks.length;\n\n          // Check if enough time has passed since the review started\n          if (reviewStartTimeRef.current) {\n            const timeSinceStart = Date.now() - reviewStartTimeRef.current;\n            if (timeSinceStart < MIN_COMPLETION_TIME_MS) {\n              console.log(\n                `Only ${Math.round(\n                  timeSinceStart / 1000\n                )}s since review started, not checking content completion yet`\n              );\n              break;\n            }\n          }\n\n          if (chunkCount < MIN_CHUNKS_FOR_COMPLETION) {\n            console.log(\"Not enough chunks received, skipping content completion check\");\n            break;\n          }\n\n          // Check if content suggests the review is complete\n          if (isReviewContentComplete(rawText, chunkCount)) {\n            console.log(\n              \"Review appears complete based on content analysis, fetching final result\"\n            );\n            await fetchFinalResult(reviewId);\n            stopPolling();\n            return;\n          }\n        }",
        "explanation": "Move the time and chunk count checks to the `pollReviewStatus` function, before calling `isReviewContentComplete`, as suggested in the `isReviewContentComplete` refactoring explanation.",
        "accepted": null
      }
    ],
    "cleanCode": "```javascript\nimport { useState, useCallback, useEffect, useRef } from 'react';\nimport { parseReviewText } from '@/lib/text-parser';\nimport { CodeReviewResponse } from '@/lib/prompts';\nimport { createStorableReview, addReview } from '@/lib/storage-utils';\nimport { Language, getLanguageById } from '@/lib/language-utils';\n\n/**\n * States for the review process\n */\nexport type ReviewStreamState = \n  | 'idle'\n  | 'loading'\n  | 'processing'\n  | 'streaming'\n  | 'completed'\n  | 'repairing'\n  | 'error';\n\n/**\n * Review state\n */\nexport interface ReviewState {\n  reviewId: string | null;\n  status: ReviewStreamState;\n  rawText: string;\n  parsed: CodeReviewResponse;\n  parseError: string | null;\n  error: string | null;\n  language: Language;\n  filename?: string;\n  progress?: number; // Progress indicator (0-100)\n}\n\n// Polling interval constants\nconst INITIAL_POLL_INTERVAL = 1000; // 1 second\nconst MAX_POLL_INTERVAL = 5000; // 5 seconds\nconst POLL_BACKOFF_FACTOR = 1.5; // Increase interval by 50% each time\nconst MIN_COMPLETION_TIME_MS = 10000; // 10 seconds - minimum time before considering content-based completion\nconst MIN_CHUNKS_FOR_COMPLETION = 10; // Need at least this many chunks before considering content-based completion\n\nconst defaultParsedResponse: CodeReviewResponse = { summary: '', suggestions: [], cleanCode: '' };\n\n/**\n * Custom hook for managing asynchronous code reviews\n * @returns An object with the review state and control functions\n */\nexport function useReviewStream() {\n  const [reviewState, setReviewState] = useState<ReviewState>({\n    reviewId: null,\n    status: 'idle',\n    rawText: '',\n    parsed: defaultParsedResponse,\n    parseError: null,\n    error: null,\n    language: getLanguageById('javascript')\n  });\n  \n  // Reference to the current polling timer\n  const pollingTimerRef = useRef<NodeJS.Timeout | null>(null);\n  \n  // Reference to current polling interval\n  const pollIntervalRef = useRef(INITIAL_POLL_INTERVAL);\n  \n  // Reference to whether polling is active\n  const isPollingRef = useRef(false);\n  \n  // Reference to review start time (for timing-based decisions)\n  const reviewStartTimeRef = useRef<number | null>(null);\n  \n  /**\n   * Stops any active polling\n   */\n  const stopPolling = useCallback(() => {\n    if (pollingTimerRef.current) {\n      clearTimeout(pollingTimerRef.current);\n      pollingTimerRef.current = null;\n    }\n    isPollingRef.current = false;\n    pollIntervalRef.current = INITIAL_POLL_INTERVAL;\n    console.log('Polling stopped');\n  }, []);\n  \n    /**\n   * Determines if a review is complete based on content analysis\n   * @param text - Raw text content to analyze\n   * @param chunkCount - Number of chunks received so far\n   * @returns Whether the review appears complete\n   */\n  const isReviewContentComplete = useCallback(\n    (text: string, chunkCount: number): boolean => {\n      const hasAllSections =\n        /SUMMARY:/i.test(text) &&\n        /SUGGESTIONS:/i.test(text) &&\n        /CLEAN[_\\s]CODE:/i.test(text);\n\n      if (!hasAllSections) {\n        console.log(\n          `Missing required sections: Summary: ${/SUMMARY:/i.test(text)}, Suggestions: ${/SUGGESTIONS:/i.test(\n            text\n          )}, CleanCode: ${/CLEAN[_\\s]CODE:/i.test(text)}`\n        );\n        return false;\n      }\n\n      const cleanCodeMatch = text.match(\n        /(?:CLEAN[_\\s]CODE:|Clean[_\\s]Code:|clean[_\\s]code:)([\\s\\S]*?)$/i\n      );\n      if (\n        !cleanCodeMatch ||\n        !cleanCodeMatch[1] ||\n        cleanCodeMatch[1].length < 100\n      ) {\n        console.log(\"Clean code section is missing or too short\");\n        return false;\n      }\n\n      const parseResult = parseReviewText(text);\n      return parseResult.success && !!parseResult.result;\n    },\n    []\n  );\n  \n  /**\n   * Fetches the final result of a review\n   * @param reviewId - The ID of the review\n   */"
  },
  "language": "javascript",
  "filename": null,
  "expiresAt": 1740983994588
}
